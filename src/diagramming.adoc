= Diagramming

Our industry's current bias towards "agile" software delivery practices has led to a preference for
use of lightweight diagramming tools to create visual representations of *[system designs]*, rather
over the production of detailed models (see *link:./modeling.adoc[Modeling]*).

Compared to modeling, the barriers to entry to diagramming is lower, and the tools are more
accessible. Diagrams are often used to communicate ideas and concepts to a wider audience, including
non-technical stakeholders, rather than as a pure development tool.

The *[domain language]* of diagramming tools is "boxes and arrows". This makes diagraming tools
relatively easy to use. The barriers to entry are much lower than for proper modeling tools like
StarUML. But this simplicity has some trade-offs:

* With diagrams, you can't enforce the same level of consistency in naming and relationships
  between components as you can with proper models.

* You can't validate, in an automated way, that diagrams are a correct representation of the code
  they document.

* You can't query diagrams (eg. "show me all the dependencies of component X").

* You can't auto-generate code from diagrams.

* Maintaining diagrams as the code changes is a more manual, and therefore more error-prone, process
  compared to maintaining models. For example, if you change the name of a class in the code, you
  will probably have to change it in several places in the diagrams, too. With a proper model, you
  should need to change it in only one place.

* Diagrams tend to be stored in either binary formats (such as images) or heavyweight plain-text
  formats that are difficult to diff. For these reasons, is is harder to maintain diagrams under
  version control systems like Git.

Drag-and-drop diagraming tools include:

* [Lucidchart]
* [Draw.io (aka diagrams.net)]
* [Microsoft Visio]

*[Diagrams-as-code]* tools include:

* [PlantUML]
* [Mermaid]
* [Graphviz]

Diagrams-as-code solutions are becoming increasingly popular as the plain-text syntax can be version
controlled and maintained alongside the source code they document.
