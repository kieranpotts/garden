= Monoliths (aka. monolithic architecture)

Before we had *link:./distributed-systems.adoc[distributed]*,
*link:./service-oriented-architecture.adoc[service-oriented]* systems, all software applications were
developed as monoliths. A monolith is a software system in which all the code is in one place, and
commonly the whole application runs in a single process.

Still today, monoliths are a great way to start building out new software systems from scratch.
Starting with a monolith means you can prototype, build, test and ship new software products quickly.
Monoliths also have some performance benefits. For example, latency is low, because all the code
runs in the same process.

However, monoliths get harder and harder to develop and deploy as time goes on. You cannot easily
scale up the teams who maintain monolithic systems. Monoliths are risky to deploy updates to,
because every change, no matter how small, requires the whole system to be redeployed. And it
tends to be expensive to scale the infrastructure on which monoliths run, because you can't target
extra resources at the specific parts of the system that need them.

Monoliths do not scale well. For this reason, modern software-as-a-service products tend to be built
as distributed systems, designed around variations of
*link:./service-oriented-architecture.adoc[service-oriented architecture]*.

*link:./modular-monolith.adoc[Modular monoliths]* are a halfway point between monoliths and
distributed systems. They offer a mix of the simplicity of monoliths and the scalability of
distributed systems, as modules can be incrementally extracted as independent services as
the system's throughput grows.
